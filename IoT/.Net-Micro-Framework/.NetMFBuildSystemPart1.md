Как объять необъятное: система сборки .NET Micro Framework Часть 1.

![enter image description here](https://habrastorage.org/files/147/683/616/1476836161574ab6a8d5129088e89c85.png)

Большинство разработчиков давно привыкли использовать ту или иную [IDE](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D1%80%D0%B5%D0%B4%D0%B0_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8) и не задумываются о том, а как, собственно, их исходный код превращается в исполняемый модуль. Современные средства разработки содержат [UI](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F) и автоматизацию сборки для огромного числа типов проектов на все случаи жизни. И это очень здорово, так как позволят не задумываться над вещами, которые не имеют непосредственного отношения к задаче, решаемой программой. Но иногда задача бывает настолько сложной, что уже не получается использовать стандартные типы проектов. И тут на поверхность всплывает "Система сборки проектов". 

Ярким примером такого типа проектов является [.NET Micro Framework](https://ru.wikipedia.org/wiki/.NET_Micro_Framework) - реализация платформы Microsoft .NET для микроконтроллеров. В этой статье я расскажу том, как устроены его [репозиторий](https://github.com/NETMF/netmf-interpreter) и система сборки.


----------

##Постановка задачи##

Прежде чем говорить о том, как устроен проект и как происходит его сборка, нужно понять какие перед проектом стоят цели и какие из этого следуют требования.

Идея .Net Micro Framewok заключается в том, чтобы разрабатывать приложения на .Net для самых маленьких устройств, управляемых микроконтроллерами. Такие устройства обладают несколькими сотнями килобайт Flash памяти и несколькими десятками килобайт RAM. Из-за ограниченности ресурсов на них нельзя использовать полноценные операционные системы, включая их IoT редакции.

Обычно разработка для таких устройств ведется на C\C++ со вставками на ассемблере и тесно связана с конкретным микроконтроллером, так как все управление "железом" происходит через запись и чтение множества регистров. При этом используются компиляторы и линковщики из специализированного набора для платформы - [Toolchain](https://en.wikipedia.org/wiki/Toolchain).

> Раньше на рынке было множество разных [архитектур
> микроконтроллеров](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80).
> Каждый производитель имел несколько семейств устройств и для каждого
> семейства могла быть своя схема регистров. Кроме того, было множество
> разных toolchain. По этому выбор микроконтроллера был крайне важной
> вехой проекта, так как потом перейти на другое устройство было очень и
> очень сложно.
> 
> Сейчас миром микроконтроллеров правит
> [ARM](https://ru.wikipedia.org/wiki/ARM_%28%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%29).
> Многие производители отказались от собственных ядер и перешли на эту
> архитектуру. Это позволило сильно унифицировать разработку и облегчить
> миграцию с одного устройства на другое. Кроме того, огромными темпами
> развивается
> [CMSIS](http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php)
> - наборт стандартных программных интерфейсов для работы с ARM микроконтроллерами, не зависящий от конкретного производителя.
> Каждый производитель поставляет реализацию CMSIS для своих устройств, что позволяет, теоретически, абстрагироваться от особенностей реализации того или иного микроконтроллера.
>
>Но, тем не мене, на рынке еще существует достаточно большое количество устройств как с отличной от ARM архитектурой, так и не имеющих реализации CMSIS.

.Net Micro Framework - это попытка поднять разработку для микроконтроллеров на более высокий уровень абстракции. Если CMSIS унифицирует устройства с ARM архитектурой, то .NetMF пытается унифицировать работу с микроконтроллерами в принципе. И, заодно, позволяет использовать мощь управляемого кода и удобство Visual Studio при разработке для встраиваемых систем. При этом никто не ограничивает использование .NetMF только микроконтроллерами. Существует его реализация для Windows, которая используется в [эмуляторе](https://geektimes.ru/post/265986/).

Таким образом, основным требованием к .NetMF является возможность запуска на любом микроконтроллере имеющем достаточное количество памяти (в документации указаны минимальные требования 256KB RAM и 512K Flash/ROM). Исходя из этого, компиляция должна происходить разными toolchain, в зависимости от выбранного устройства. Архитектура системы должна учитывать то, что работа на низком уровне, с "железом" может вестись как по средствам одной из реализаций CMSIS, так и любой другой библиотеки или операционной системы( как в случае эмулятора для Windows).

Другие требования, связанные с реализацией .Net, системы безопасности, отладки и тд. я не буду рассматривать, так как они не имеют влияния на систему сборки проекта.

##Архитектура решения##

Итак, к системе предявляются три основных требования:

1. Возможность запуска на любом микроконтроллере, обладающем необходимым объемом памяти.
2. Возможность использовать разные toolchain.
3. Возможность использования как API операционной системы, так и широкий набор библиотек для работы с "железом".

Причем пункт 2 и 3 являются следствием первого пункта.

.Net Micro Framework имеет следующую архитектуру:

![enter image description here](https://habrastorage.org/storage/fdd6d69f/11f7e201/37802566/9f6ae01e.jpg)

Система разделена на несколько слоев:

Два верхних слоя (приложения пользователя и системные библиотеки) написаны на управляем коде. Это то, что мы видим в Visual Studio. Слой аппаратного обеспечения — это и есть само «железо» на котором запущен .NetMF. Ну а слой TinyCLR — это среда исполнения кода. 

TinyCLR разделена на 3 части:

1. CLR — тут все, что касается исполнения управляемого кода, типизации, сборки мусора и т.д.
2. PAL (Platform Abstraction Layer) — Классы и функции для работы с общими абстракциями, такими как счетчики, таймеры, ввод-вывод. Эти классы одинаковы для всех аппаратных платформ.
3. HAL (Hardware Abstraction Layer) — Классы и функции дня работы непосредственно с «железом».

Разделение на PAL и HAL позволяет требование номер три (Возможность использования как API операционной системы, так и широкий набор библиотек для работы с "железом").

Абстракция HAL представляет собой набор интерфейсов с которыми работает PAL и более высокие уровни. Это позволяет делать множество реализаций для разных платформ и использовать любые библиотеки или API в этих реализациях.

Таким образом, разработчики разделяют код на следующие слои:

![enter image description here](https://github.com/NETMF/netmf-interpreter/wiki/images/NetMFLayerDiagram.png)

Часть, обозначенная на схеме как Native Code написана на C/C++. Managed code написан на C#. Соответственно, разные части репозитория компилируются разными компиляторами. 

Чтобы реализовать возможность компиляции разными toolchain, при этом сохранить целостность проекта, нужна мощная система сборки проектов, которая позволяет производить гибкую настройку всего процесса. Система сборки первых версий .NetMF была основана на [MAKEFILE](https://habrahabr.ru/post/155201/) . Затем произошел переход на [MSBuild](https://ru.wikipedia.org/wiki/MSBuild). Причем, на тот момент, сборка Visual C++ проектов в Visual Studio не использовала MSBuild (а большая часть NetMF написана на C\C++), по этому пришлось делать "нестандартные" проект. Результат получился копией системы сборки, основанной на MAKEFILE, так как это было сделать быстрее и проще всего.

В итоге, все это позволило реализовать все требования, связанные с мультиплатформенностью .NetMF.

##Особенности реализации##

Недавно была опубликована [статья](https://github.com/NETMF/netmf-interpreter/wiki/BuildSystemRequirements) о системе сборки .NetMF. Автор описывает проблемы, которые приходится решать при сборке проекта.

Имеется несколько сценариев работы системы сборки .NetMF:

1. Сборка компонентов, необходимых для построения остальной части репозитория. А именно, любых расширений, которые требуются для сборки, но не входят в стандартный набор системы сборки проектов.
2. Сборка и настройка утилит, необходимых для сборки проекта. Этот пункт важно отличить от предыдущего. Если в первом пункте собирались именно расширения системы сборки (например, расширения для MSBuild) то в этом пункте собираются именно дополнительные утилиты. Например утилита, делающая цифровые подписи.
3. Сборка SDK, которая будет использоваться разработчиками при создании приложения для .NetMF в Visual Studio. Сюда входят VSIX палагин и необходимые библиотеки, включаемые в проект.
4. Сборка "портов" для аппаратного обеспечения. То есть сборка TinyCLR для конкретной платы.

Прежде чем рассмотреть каждый сценарий, нужно еще раз напомнить, что .Net Micro Framework является "архитектурно нейтральной" включая как как big-endian так и little-endian системы. По этому для сборки может быть использовано множество разных toolchain. Для этого, как я уже писал выше, используется сложный скрипт для MSBuild. Причем при разработке этого скрипта, разработчики исходили из очень интересной интерпретации требования номер два: возможность использовать разные toolchain. Для них важно было во первых иметь возможность добавлять новые toolchain, не сломав существующее решение. А во вторых дать пользователю возможность выбора toolchain. Например, сечйас компиляцию можно делать как с помощью [GCC ARM](https://launchpad.net/gcc-arm-embedded) так и с помощью [MDK](http://www2.keil.com/mdk5/).

###Сборка компонентов для сборки###

На этом этапе из исходных кодов собираются расширения, использующиеся MSBuild при сборке остальной части репозитория. Причины, по которым этот сценарий отделен от остальных заключаются в особенности реализации MSBuild. Дело в том, что перед началом процесса сборки, MSBuild сразу загружает все необходимые компоненты. Это значит что они должны уже существовать к этому моменту. Кроме того, у MSBuild есть системы кэширования, из-за которой собранные компоненты могут быть не доступны если попытаться собрать остальную часть репозитория сразу после сборки предварительных компонентов.

По этому нужно сначала собрать расширения, затем полностью выгрузить MSBuild и уже только потом собирать остальной репозиторий.

###Сборка и настройка утилит###

В процессе сборки .NetMF участвует множество утилит. Некоторые из них занимаются подписыванием модулей, некоторые сжатием, некоторые преобразованием форматов и т.д. Эти утилиты в основном представляют собой консольные приложения Windows. Они участвуют как в сборке "портов" для устройств, так и в сборке SDK. По этому они должны быть собраны заранее. В MSBuild они используются с помощью скриптов-оберток(wrappers).

###Сборка SDK###

Процесс создания инфраструктуры для разработки приложения для .NEtMF включает в себя множество шагов:

1. Сборка предварительных частей. Этот этап включает в себя 1 и 2 пункты из списка выше
2. Коспиляция исходного кода в DLL
3. Преобразования DLL в PE файлы содержащие отладочную информацию как для big-endian так и для little-endian систем.
4. Сборка компонентов для интеграции с Visual Studio.
5. Подписывание всех компонентов перед упаковкой в пакеты
6. Сборка VSIX пакетов для поддерживающихся версий Visual Studio
7. Подписывание VSIX пакетов
8. Сборка SDK MSI пакетов
9. Подписывание SDK MSI пакетов

Тут стоит отметить, что пакеты требуется пописывать несколько раз на нескольких этапах. И тут так же проявляется проблема, описанная выше (предварительная сборка). В SDK включены asseblies, которые требуются для сборки SDK. По этому и нужен пункт 1.

###Сборка "портов"###

Прошивка для конкретного устройства так же появляется в результате выполнения множества шагов:

1. Компиляция нативного кода в obj файлы
2. Компиляция нативного кода в .lib файлы
3. Линковка native OBJ и libs файлов в бинарный файл
4. Выполнение Link/Locate над бинарным файлом для получения образа [XIP](https://ru.wikipedia.org/wiki/Execute_in_place) для flash
5. Подписывание бинарных образов для поддержки безопасной загрузки
6. Создание спеиализированного сжатого и подписанного пакета, который может использоваться программой MFUpdate
7. Генерация Образа раздела онфигурации для Flash устройства
8. Компиляция управляемого кода в управляемые сборки
9. Генерация необходимых компонентов для взаимодействия между нативным и управляемым кодом
10. Генерция PE файлов, которе исполняются в .NetMF, и соответствующих файлов с отладочной информацией для big-endian и little-endian систем
11. Генерация DAT из управляемых сборок, которые будут загружены во flash устройства

Все это выполняется с помощью скриптов для MSBuild.


###Разрешение зависимостей###

Этот пункт вытекает из требования об использовании широкого набора библиотек для работы с "железом".

Любой проект так или иначе сталкивается со ссылками между его составными частями. Это могут быть как ссылки между файлами, так и ссылки между программными модулями, такими как .exe и .dll. В общем случае существует два типа зависимостей, которые нужно разрешать:

1. *Жесткие зависимости*.
Этот тип зависимостей появляется, одна часть программы явно зависит от другой. Например, приложение A использует библиотеку xyz. Такие зависимости легко могут быть автоматически разрешены. В этом случае системе сборки понятно, что сначала нужно собрать библиотеку xyz, а потом уже приложение A. В более современных системах сборки, xyz и A могут собираться параллельно в разных потоках, но линковка все равно будет происходить после того, как будут собраны все компоненты.
2. *Мягкие зависимости*.
Этот тип зависимостей возникает, когда одна часть программы ссылается на интерфейс или API, которые могут иметь множество равнозначных реализаций. В этом случае, система сборки не может автоматически определить, какую из реализаций ей использовать. Если существует только одна реализация, то система сборки сможет определить, что ей использовать. Если реализаций несколько, то ей нужно явно тем или иным способом указать, что ей нужно брать.

В .NetMF есть как жесткие, так и мягкие зависимости. И, если жесткие зависимости разрешаются автоматически, то проблема мягких зависимостей является одной из самых сложных. Сейчас она решается путем указания определенных значений в переменных окружения и указания ссылок на реализации в скриптах MSBuild. И, хотя это работает, решение это плохое. Скрипты настолько сложны и полны ссылок друг на друга, что понять, где именно нужно поменять ссылки очень сложно.

##Заключение##

Подвозя итог, можно сказать, что .NetMF из-за своей "архитектурной нейтральности" имеет весьма сложную структуру. Следствием этого является очень сложная система сборки проекта. Я сделал небольшой обзор задач, их общих решений и некоторых особенностей системы сборки .NetMF. В следующей статья я расскажу о деталях реализации системы сборки с помощью скриптов для MSBuild.
